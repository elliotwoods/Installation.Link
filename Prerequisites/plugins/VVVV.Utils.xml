<?xml version="1.0"?>
<doc>
    <assembly>
        <name>VVVV.Utils</name>
    </assembly>
    <members>
        <member name="T:VVVV.Utils.Animation.Particle">
            <summary>
            A particle class with common data fields.
            The Update method is virtual, so it can be overwritten in sub classes.
            </summary>
        </member>
        <member name="M:VVVV.Utils.Animation.Particle.#ctor(System.Double,System.Double)">
            <summary>
            Creates a new Particle instance and sets the time.
            </summary>
            <param name="time">Current system time in seconds.</param>
            <param name="lifeTime">Max life time in seconds, -1 is infinite lifetime</param>
        </member>
        <member name="M:VVVV.Utils.Animation.Particle.UpdateTime(System.Double)">
            <summary>
            Updates the time variables dt and age.
            </summary>
            <param name="time">Current system time in seconds</param>
        </member>
        <member name="M:VVVV.Utils.Animation.Particle.Update(System.Double)">
            <summary>
            Updates the paticle age and position.
            </summary>
            <param name="time">Current system time in seconds.</param>
            <returns>False if the particle is dead.</returns>
        </member>
        <member name="T:VVVV.Utils.Application.AppInfo">
            <summary>
            provides information about the entry assembly
            </summary>
        </member>
        <member name="M:VVVV.Utils.Collections.DictionaryExtensions.ValueOrDefault``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
            <summary>
            From http://www.haiders.net/post/Dictionary-Lookup-avoiding-KeyNotFound-Exception.aspx
            </summary>
            <param name="dictionary"></param>
            <param name="key">The key to look up.</param>
            <returns>The value associated with the key or default(TValue) of key not found.</returns>
        </member>
        <member name="T:VVVV.Utils.VColor.RGBAColor">
            <summary>
            256-bit color struct, compatible with vvvv colors.
            There is an implicit cast to the C# Color type and an explictit cast from C# color to RGBAColor.
            Aswell as implicit casts from and to Vector4D.
            </summary>
        </member>
        <member name="F:VVVV.Utils.VColor.RGBAColor.R">
            <summary>
            The Red data field
            </summary>
        </member>
        <member name="F:VVVV.Utils.VColor.RGBAColor.G">
            <summary>
            The Green data field
            </summary>
        </member>
        <member name="F:VVVV.Utils.VColor.RGBAColor.B">
            <summary>
            The Blue data field
            </summary>
        </member>
        <member name="F:VVVV.Utils.VColor.RGBAColor.A">
            <summary>
            The Alpha data field
            </summary>
        </member>
        <member name="M:VVVV.Utils.VColor.RGBAColor.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            vvvv color constructor
            </summary>
            <param name="Red">red component, 0..1</param>
            <param name="Green">green component, 0..1</param>
            <param name="Blue">blue component, 0..1</param>
            <param name="Alpha">alpha component, 0..1</param>
        </member>
        <member name="M:VVVV.Utils.VColor.RGBAColor.#ctor(System.Double[])">
            <summary>
            vvvv color constructor
            </summary>
            <param name="colors">double array of length 4 (red, green, blue, alpha) with values between 0..1</param>
        </member>
        <member name="M:VVVV.Utils.VColor.RGBAColor.ToString">
            <summary>
            Get string name for the color
            </summary>
            <returns>Color name</returns>
        </member>
        <member name="M:VVVV.Utils.VColor.RGBAColor.op_Implicit(VVVV.Utils.VColor.RGBAColor)~VVVV.Utils.VMath.Vector4D">
            <summary>
            Casts a color to a 4d-vector
            </summary>
            <param name="a">color to cast</param>
            <returns>4d-vector with same values than the input color</returns>
        </member>
        <member name="M:VVVV.Utils.VColor.RGBAColor.op_Implicit(VVVV.Utils.VMath.Vector4D)~VVVV.Utils.VColor.RGBAColor">
            <summary>
            Casts a 4d-vector to a color
            </summary>
            <param name="a">4d-vector to cast</param>
            <returns>color with same values like than input 4d-vector</returns>
        </member>
        <member name="M:VVVV.Utils.VColor.RGBAColor.op_Implicit(System.Drawing.Color)~VVVV.Utils.VColor.RGBAColor">
            <summary>
            Casts a C# color to a color
            </summary>
            <param name="C">C# color to cast</param>
            <returns>Same Color than the input C# color</returns>
        </member>
        <member name="M:VVVV.Utils.VColor.RGBAColor.op_Explicit(VVVV.Utils.VColor.RGBAColor)~System.Drawing.Color">
            <summary>
            Explicit cast from color to C# color
            </summary>
            <param name="C">color to cast</param>
            <returns>C# color with closest values to the input the color</returns>
        </member>
        <member name="M:VVVV.Utils.VColor.RGBAColor.op_UnaryPlus(VVVV.Utils.VColor.RGBAColor)">
            <summary>
            + color, makes no changes to a color
            </summary>
            <param name="C"></param>
            <returns>Input color C unchanged</returns>
        </member>
        <member name="M:VVVV.Utils.VColor.RGBAColor.op_UnaryNegation(VVVV.Utils.VColor.RGBAColor)">
            <summary>
            - color, flips the sign off all color components
            </summary>
            <param name="C"></param>
            <returns>New color with all components of C negatived</returns>
        </member>
        <member name="M:VVVV.Utils.VColor.RGBAColor.op_LogicalNot(VVVV.Utils.VColor.RGBAColor)">
            <summary>
            ! color, calculates the complementary color
            </summary>
            <param name="C"></param>
            <returns>Complementary color to the input color C</returns>
        </member>
        <member name="M:VVVV.Utils.VColor.RGBAColor.op_OnesComplement(VVVV.Utils.VColor.RGBAColor)">
            <summary>
            ~ color, calculates the brighness of a color with the formula 0.222 * R + 0.707 * G + 0.071 * B
            </summary>
            <param name="C"></param>
            <returns>Brightness value of the input color C</returns>
        </member>
        <member name="M:VVVV.Utils.VColor.RGBAColor.op_Addition(VVVV.Utils.VColor.RGBAColor,VVVV.Utils.VColor.RGBAColor)">
            <summary>
            Adds the color components of two colors
            </summary>
            <param name="C1"></param>
            <param name="C2"></param>
            <returns>Sum of two colors</returns>
        </member>
        <member name="M:VVVV.Utils.VColor.RGBAColor.op_Subtraction(VVVV.Utils.VColor.RGBAColor,VVVV.Utils.VColor.RGBAColor)">
            <summary>
            Subtracts the color components of two colors
            </summary>
            <param name="C1"></param>
            <param name="C2"></param>
            <returns>Difference of two colors</returns>
        </member>
        <member name="M:VVVV.Utils.VColor.RGBAColor.op_Multiply(VVVV.Utils.VColor.RGBAColor,System.Double)">
            <summary>
            Multiplies a color with a factor
            </summary>
            <param name="C"></param>
            <param name="factor"></param>
            <returns>Color multiplied by the factor</returns>
        </member>
        <member name="M:VVVV.Utils.VColor.RGBAColor.op_Multiply(System.Double,VVVV.Utils.VColor.RGBAColor)">
            <summary>
            Multiplies a factor with a color
            </summary>
            <param name="factor"></param>
            <param name="C"></param>
            <returns>Color multiplied by the factor</returns>
        </member>
        <member name="M:VVVV.Utils.VColor.RGBAColor.op_Multiply(VVVV.Utils.VColor.RGBAColor,VVVV.Utils.VColor.RGBAColor)">
            <summary>
            Multiplies two colors, RGBA component wise
            </summary>
            <param name="C1"></param>
            <param name="C2"></param>
            <returns>Color C1 multiplied by color C2</returns>
        </member>
        <member name="P:VVVV.Utils.VColor.RGBAColor.Color">
            <summary>
            C# color type property, can be used for conversion
            Note, that there is also implicit casting from C# color, and explicit casting to C# color
            </summary>
        </member>
        <member name="T:VVVV.Utils.VColor.VColor">
            <summary>
            The vvvv c# color routines library
            </summary>
        </member>
        <member name="F:VVVV.Utils.VColor.VColor.Red">
            <summary>
            Red as constant, (1,0,0,1)
            </summary>
        </member>
        <member name="F:VVVV.Utils.VColor.VColor.Green">
            <summary>
            Green as constant, (0,1,0,1)
            </summary>
        </member>
        <member name="F:VVVV.Utils.VColor.VColor.Blue">
            <summary>
            Blue as constant, (0,0,1,1)
            </summary>
        </member>
        <member name="F:VVVV.Utils.VColor.VColor.White">
            <summary>
            White as constant, (1,1,1,1)
            </summary>
        </member>
        <member name="F:VVVV.Utils.VColor.VColor.Black">
            <summary>
            Black as constant, (0,0,0,1)
            </summary>
        </member>
        <member name="M:VVVV.Utils.VColor.VColor.Complement(VVVV.Utils.VColor.RGBAColor)">
            <summary>
            Function to calculate the complementary color
            Note that the ! operator of RGBAColor does the same
            </summary>
            <param name="Col">Input color</param>
            <returns>Complement color of the RGB channels of the input color</returns>
        </member>
        <member name="M:VVVV.Utils.VColor.VColor.Offset(VVVV.Utils.VColor.RGBAColor,System.Double)">
            <summary>
            Adds a value to the RGB channels of a color and takes the result modulo 1
            </summary>
            <param name="Col"></param>
            <param name="Offset"></param>
            <returns>(Col.RGB + Offset) modulo 1</returns>
        </member>
        <member name="M:VVVV.Utils.VColor.VColor.Invert(System.Drawing.Color)">
            <summary>
            Function to get black or white, which ever has higher contrast to the input color, e.g. for text on colored backgrounds
            </summary>
            <param name="C">Input color</param>
            <returns>Black or white in C# color format</returns>
        </member>
        <member name="M:VVVV.Utils.VColor.VColor.LerpRGBA(VVVV.Utils.VColor.RGBAColor,VVVV.Utils.VColor.RGBAColor,System.Double)">
            <summary>
            Linear interpolation (blending) between two colors
            </summary>
            <param name="Col1"></param>
            <param name="Col2"></param>
            <param name="x">Blending factor, 0..1</param>
            <returns>Linear interpolation (blending) between Col1 and Col2 if x in the range ]0..1[, Col1 if x = 0, Col2 if x = 1</returns>
        </member>
        <member name="M:VVVV.Utils.VColor.VColor.BilerpRGBA(System.Double,System.Double,VVVV.Utils.VColor.RGBAColor,VVVV.Utils.VColor.RGBAColor,VVVV.Utils.VColor.RGBAColor,VVVV.Utils.VColor.RGBAColor)">
            <summary>
            2d linear interpolation in x and y direction for colors
            </summary>
            <param name="x">The x position where to interpolate, 0..1</param>
            <param name="y">The y position where to interpolate, 0..1</param>
            <param name="P1">Upper left color</param>
            <param name="P2">Upper right color</param>
            <param name="P3">Lower right color</param>
            <param name="P4">Lower left color</param>
            <returns>Interpolated color between the 4 colors in the corners</returns>
        </member>
        <member name="M:VVVV.Utils.VColor.VColor.Brightness(VVVV.Utils.VColor.RGBAColor)">
            <summary>
            Calculates the brighness of a color with the formula 0.222 * R + 0.707 * G + 0.071 * B
            </summary>
            <param name="C"></param>
            <returns>Brightness value of the input color C</returns>
        </member>
        <member name="M:VVVV.Utils.VColor.VColor.HSLAToColor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Get a C# color type from hue, saturation, lightness and alpha values
            </summary>
            <param name="H"></param>
            <param name="S"></param>
            <param name="L"></param>
            <param name="A"></param>
            <returns>C# Color in RGB format</returns>
        </member>
        <member name="M:VVVV.Utils.VColor.VColor.FromHSVA(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Get a color from hue, saturation, brightness and alpha values
            </summary>
            <param name="Hue"></param>
            <param name="Saturation"></param>
            <param name="Value"></param>
            <param name="Alpha"></param>
            <returns>Color in RGB format</returns>
        </member>
        <member name="M:VVVV.Utils.VColor.VColor.HSVtoRGB(System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@)">
            <summary>
            Function to convert HSV values to RGB values
            
            merged methods from EasyRGB (http://www.easyrgb.com/math.php?MATH=M21#text21) 
            and the book GRAPHICS GEMS
            </summary>
            <param name="H"></param>
            <param name="S"></param>
            <param name="V"></param>
            <param name="Red">Output parameter, this variable gets filled with the red value</param>
            <param name="Green">Output parameter, this variable gets filled with the green value</param>
            <param name="Blue">Output parameter, this variable gets filled with the blue value</param>
        </member>
        <member name="M:VVVV.Utils.VColor.VColor.RGBtoHSV(System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@)">
            <summary>
            Function to convert RGB values to HSV values
            
            merged from http://www.easyrgb.com/math.php?MATH=M20#text20
            and http://www.efg2.com/Lab/Graphics/Colors/HSV.htm
            </summary>
            <param name="R"></param>
            <param name="G"></param>
            <param name="B"></param>
            <param name="Hue">Output parameter, this variable gets filled with the Hue value</param>
            <param name="Sat">Output parameter, this variable gets filled with the Saturation value</param>
            <param name="Value">Output parameter, this variable gets filled with the Brightness value</param>
            <returns>false, if color is gray, hue has no defined value in that case</returns>
        </member>
        <member name="M:VVVV.Utils.VColor.VColor.HSLtoRGB(System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@)">
            <summary>
            Computes RGB values from HSL values, found on:
            http://www.geekymonkey.com/Programming/CSharp/RGB2HSL_HSL2RGB.htm
            </summary>
            <param name="H">Hue</param>
            <param name="S">Saturation</param>
            <param name="L">Lightness</param>
            <param name="Red">Output parameter, gets filled with the red value</param>
            <param name="Green">Output parameter, gets filled with the green value</param>
            <param name="Blue">Output parameter, gets filled with the blue value</param>
        </member>
        <member name="M:VVVV.Utils.VColor.VColor.RGBtoHSL(System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@)">
            <summary>
            Computes HSL values from RGB values, found on:
            http://www.geekymonkey.com/Programming/CSharp/RGB2HSL_HSL2RGB.htm
            </summary>
            <param name="r">Red</param>
            <param name="g">Green</param>
            <param name="b">Blue</param>
            <param name="h">Output parameter, gets filled with the hue value</param>
            <param name="s">Output parameter, gets filled with the saturation value</param>
            <param name="l">Output parameter, gets filled with the lightness value</param>
            <returns>false, if color is gray, in that case hue is not defined</returns>
        </member>
        <member name="T:VVVV.Utils.Concurrent.BlockingQueue`1">
            <summary>
            Implementation of BlockingQueue based on
            http://stackoverflow.com/questions/530211/creating-a-blocking-queuet-in-net
            </summary>
        </member>
        <member name="M:VVVV.Utils.Concurrent.BlockingQueue`1.Enqueue(`0)">
            <summary>
            Puts an item in the queue.
            </summary>
        </member>
        <member name="M:VVVV.Utils.Concurrent.BlockingQueue`1.TryDequeue(`0@)">
            <summary>
            Takes an item from the queue. Blocks if no item is available.
            Returns false if queue was closed.
            </summary>
        </member>
        <member name="M:VVVV.Utils.Concurrent.BlockingQueue`1.Close">
            <summary>
            Wakes up all pending dequeues.
            </summary>
        </member>
        <member name="P:VVVV.Utils.Concurrent.BlockingQueue`1.Count">
            <summary>
            Gets the number of elements contained in the queue.
            </summary>
        </member>
        <member name="T:VVVV.Utils.Crypto.StringHasher">
            <summary>
            StringHasher.
            </summary>
        </member>
        <member name="T:VVVV.Utils.Disposable">
            <summary>
            Implementation of IDisposable. Override the methods DisposeManaged or DisposeUnmanaged.
            </summary>
        </member>
        <member name="T:VVVV.Utils.ManagedVCL.TopControl">
            <summary>
            Modified version of http://www.managed-vcl.com/downloads/ManagedVCLControl.zip
            Added method ProcessKeyPreview to be able to forward keys like
            HOME, INSERT and arrow keys.
            Overwrite IsDialogKey to control application specific behavior.
            </summary>
        </member>
        <member name="F:VVVV.Utils.ManagedVCL.TopControl.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:VVVV.Utils.ManagedVCL.TopControl.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
        </member>
        <member name="M:VVVV.Utils.ManagedVCL.TopControl.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:VVVV.Utils.VMath.Matrix4x4">
            <summary>
            4x4 transform matrix struct with operators, much faster then matrix classes
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Matrix4x4.m11">
            <summary>
            The 1. data element of 1. row
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Matrix4x4.m12">
            <summary>
            The 2. data element of 1. row
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Matrix4x4.m13">
            <summary>
            The 3. data element of 1. row
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Matrix4x4.m14">
            <summary>
            The 4. data element of 1. row
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Matrix4x4.m21">
            <summary>
            The 1. data element of 2. row
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Matrix4x4.m22">
            <summary>
            The 2. data element of 2. row
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Matrix4x4.m23">
            <summary>
            The 3. data element of 2. row
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Matrix4x4.m24">
            <summary>
            The 4. data element of 2. row
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Matrix4x4.m31">
            <summary>
            The 1. data element of 3. row
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Matrix4x4.m32">
            <summary>
            The 2. data element of 3. row
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Matrix4x4.m33">
            <summary>
            The 3. data element of 3. row
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Matrix4x4.m34">
            <summary>
            The 4. data element of 3. row
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Matrix4x4.m41">
            <summary>
            The 1. data element of 4. row
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Matrix4x4.m42">
            <summary>
            The 2. data element of 4. row
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Matrix4x4.m43">
            <summary>
            The 3. data element of 4. row
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Matrix4x4.m44">
            <summary>
            The 4. data element of 4. row
            </summary>
        </member>
        <member name="M:VVVV.Utils.VMath.Matrix4x4.#ctor(VVVV.Utils.VMath.Matrix4x4)">
            <summary>
            Copy constructor for the 4x4 matrix struct
            </summary>
            <param name="A">Matrix to be copied</param>
        </member>
        <member name="M:VVVV.Utils.VMath.Matrix4x4.#ctor(VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D)">
            <summary>
            Contructor for a 4x4 matrix from four 4d-vectors, the vectors are treated as rows
            </summary>
            <param name="v1">1. row</param>
            <param name="v2">2. row</param>
            <param name="v3">3. row</param>
            <param name="v4">4. row</param>
        </member>
        <member name="M:VVVV.Utils.VMath.Matrix4x4.#ctor(VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D,System.Boolean)">
            <summary>
            Contructor for a 4x4 matrix from four 4d-vectors, the vectors are treated as rows or columns depending on the boolean parameter
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="v3"></param>
            <param name="v4"></param>
            <param name="columns">if true, the vectors are treated as columns, else as rows</param>
        </member>
        <member name="M:VVVV.Utils.VMath.Matrix4x4.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Contructor for a 4x4 matrix from 16 float values, order is row major
            </summary>
            <param name="m11"></param>
            <param name="m12"></param>
            <param name="m13"></param>
            <param name="m14"></param>
            <param name="m21"></param>
            <param name="m22"></param>
            <param name="m23"></param>
            <param name="m24"></param>
            <param name="m31"></param>
            <param name="m32"></param>
            <param name="m33"></param>
            <param name="m34"></param>
            <param name="m41"></param>
            <param name="m42"></param>
            <param name="m43"></param>
            <param name="m44"></param>
        </member>
        <member name="M:VVVV.Utils.VMath.Matrix4x4.#ctor(VVVV.Utils.VMath.Vector4D)">
            <summary>
            Contructor for a 4x4 matrix from a Vector4D v, given by the matrix representation of Quaternions into a Matrix4x4
            ( see http://en.wikipedia.org/wiki/Quaternion#Matrix_representations )
            </summary>
            <param name="v"></param>
        </member>
        <member name="M:VVVV.Utils.VMath.Matrix4x4.op_UnaryPlus(VVVV.Utils.VMath.Matrix4x4)">
            <summary>
            + matrix, makes no changes to a matrix
            </summary>
            <param name="A"></param>
            <returns>Input matrix A unchanged</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Matrix4x4.op_UnaryNegation(VVVV.Utils.VMath.Matrix4x4)">
            <summary>
            - matrix, flips the sign off all matrix components
            </summary>
            <param name="A"></param>
            <returns>New matrix with all components of A negatived</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Matrix4x4.op_LogicalNot(VVVV.Utils.VMath.Matrix4x4)">
            <summary>
            ! matrix, calculates the inverse of the matrix
            
            optimized 4x4 matrix inversion using cramer's rule, found in the game engine http://www.ogre3d.org
            takes about 1,8ns to execute on intel core2 duo 2Ghz, the intel reference
            implementation (not assembly optimized) was about 2,2ns.
            http://www.intel.com/design/pentiumiii/sml/24504301.pdf
            </summary>
            <param name="A"></param>
            <returns>Inverse matrix</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Matrix4x4.op_OnesComplement(VVVV.Utils.VMath.Matrix4x4)">
            <summary>
            ~ matrix, calculates the determinant of the matrix
            </summary>
            <param name="A"></param>
            <returns>Determinat of the matrix</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Matrix4x4.op_Addition(VVVV.Utils.VMath.Matrix4x4,VVVV.Utils.VMath.Matrix4x4)">
            <summary>
            matrix + matrix, adds the values of two matrices component wise
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns>New matrix with the pair wise sum of the components of A and B</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Matrix4x4.op_Addition(VVVV.Utils.VMath.Matrix4x4,System.Double)">
            <summary>
            matrix + value, adds a value to all matrix components
            </summary>
            <param name="A"></param>
            <param name="b"></param>
            <returns>New matrix with b added to all components of A</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Matrix4x4.op_Addition(System.Double,VVVV.Utils.VMath.Matrix4x4)">
            <summary>
            value + matrix, adds a value to all matrix components
            </summary>
            <param name="a"></param>
            <param name="B"></param>
            <returns>New matrix with b added to all components of A</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Matrix4x4.op_Subtraction(VVVV.Utils.VMath.Matrix4x4,VVVV.Utils.VMath.Matrix4x4)">
            <summary>
            matrix - matrix, subtracts the components of B from the components of A
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns>New matrix with the pair wise difference of the components of A and B</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Matrix4x4.op_Subtraction(VVVV.Utils.VMath.Matrix4x4,System.Double)">
            <summary>
            matrix - value, subtracts a value from all matrix components
            </summary>
            <param name="A"></param>
            <param name="b"></param>
            <returns>New matrix with b subtracted from all components of A</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Matrix4x4.op_Subtraction(System.Double,VVVV.Utils.VMath.Matrix4x4)">
            <summary>
            value - matrix, subtracts all matrix components from a value 
            </summary>
            <param name="a"></param>
            <param name="B"></param>
            <returns>New matrix with all components of A subtracted from b</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Matrix4x4.op_Multiply(VVVV.Utils.VMath.Matrix4x4,VVVV.Utils.VMath.Matrix4x4)">
            <summary>
            matrix * matrix, performs a matrix multiplication
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns>Matrix product of A and B</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Matrix4x4.op_Multiply(VVVV.Utils.VMath.Matrix4x4,VVVV.Utils.VMath.Vector4D)">
            <summary>
            matrix * 4d vector, applies a matrix transform to a 4d-vector
            </summary>
            <param name="A"></param>
            <param name="b"></param>
            <returns>Vector b transformed by matrix A</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Matrix4x4.op_Multiply(VVVV.Utils.VMath.Matrix4x4,VVVV.Utils.VMath.Vector3D)">
            <summary>
            matrix * 3d vector, applies a matrix transform to a 3d-vector, (x, y, z, 1) and divides by w
            </summary>
            <param name="A"></param>
            <param name="b"></param>
            <returns>Vector b transformed by matrix A</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Matrix4x4.op_Multiply(VVVV.Utils.VMath.Matrix4x4,VVVV.Utils.VMath.Vector2D)">
            <summary>
            matrix * 2d vector, applies a matrix transform to a 2d-vector, (x, y, 0, 1)
            </summary>
            <param name="A"></param>
            <param name="b"></param>
            <returns>Vector b transformed by matrix A</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Matrix4x4.op_Multiply(VVVV.Utils.VMath.Matrix4x4,System.Double)">
            <summary>
            matrix * value, multiplies all matrix components with a value
            </summary>
            <param name="A"></param>
            <param name="b"></param>
            <returns>New matrix with all components of A multiplied by b</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Matrix4x4.op_Multiply(System.Double,VVVV.Utils.VMath.Matrix4x4)">
            <summary>
            value * matrix, multiplies all matrix components with a value
            </summary>
            <param name="a"></param>
            <param name="B"></param>
            <returns>New matrix with all components of B multiplied by a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Matrix4x4.op_Division(VVVV.Utils.VMath.Matrix4x4,System.Double)">
            <summary>
            matrix / value, divides all matrix components with a value
            </summary>
            <param name="A"></param>
            <param name="b"></param>
            <returns>New matrix with all components of A divided by b</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Matrix4x4.op_Division(System.Double,VVVV.Utils.VMath.Matrix4x4)">
            <summary>
            value / matrix, divides a value by all matrix components
            </summary>
            <param name="a"></param>
            <param name="B"></param>
            <returns>New matrix with a divided by all components of B</returns>
        </member>
        <member name="P:VVVV.Utils.VMath.Matrix4x4.row1">
            <summary>
            Get/Set the 1. row as 4d-vector
            </summary>
        </member>
        <member name="P:VVVV.Utils.VMath.Matrix4x4.row2">
            <summary>
            Get/Set the 2. row as 4d-vector
            </summary>
        </member>
        <member name="P:VVVV.Utils.VMath.Matrix4x4.row3">
            <summary>
            Get/Set the 3. row as 4d-vector
            </summary>
        </member>
        <member name="P:VVVV.Utils.VMath.Matrix4x4.row4">
            <summary>
            Get/Set the 4. row as 4d-vector
            </summary>
        </member>
        <member name="P:VVVV.Utils.VMath.Matrix4x4.col1">
            <summary>
            Get/Set the 1. column as 4d-vector
            </summary>
        </member>
        <member name="P:VVVV.Utils.VMath.Matrix4x4.col2">
            <summary>
            Get/Set the 2. column as 4d-vector
            </summary>
        </member>
        <member name="P:VVVV.Utils.VMath.Matrix4x4.col3">
            <summary>
            Get/Set the 3. column as 4d-vector
            </summary>
        </member>
        <member name="P:VVVV.Utils.VMath.Matrix4x4.col4">
            <summary>
            Get/Set the 4. column as 4d-vector
            </summary>
        </member>
        <member name="P:VVVV.Utils.VMath.Matrix4x4.Item(System.Int32)">
            <summary>
            Unsafe but very fast indexer for 4x4 matrix, [0..15]
            </summary>
        </member>
        <member name="P:VVVV.Utils.VMath.Matrix4x4.Item(System.Int32,System.Int32)">
            <summary>
            Unsafe but very fast 2-d indexer for 4x4 matrix, [0..3, 0..3]
            </summary>
        </member>
        <member name="T:VVVV.Utils.VMath.Tweener">
            <summary>
            Tweener routines, interpolation functions for a value in the range [0..1] in various shapes
            
            Code by west
            </summary>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.QuadEaseIn(System.Double)">
            <summary>
            QUADRATIC EASE IN
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.QuadEaseOut(System.Double)">
            <summary>
            QUADRATIC EASE OUT
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.QuadEaseInOut(System.Double)">
            <summary>
            QUADRATIC EASE IN/OUT
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.QuadEaseOutIn(System.Double)">
            <summary>
            QUADRATIC EASE OUT/IN
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.CubicEaseIn(System.Double)">
            <summary>
            CUBIC EASE IN
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.CubicEaseOut(System.Double)">
            <summary>
            CUBIC EASE OUT
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.CubicEaseInOut(System.Double)">
            <summary>
            CUBIC EASE IN/OUT
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.CubicEaseOutIn(System.Double)">
            <summary>
            CUBIC EASE OUT/IN
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.QuarticEaseIn(System.Double)">
            <summary>
            QUARTIC EASE IN
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.QuarticEaseOut(System.Double)">
            <summary>
            QUARTIC EASE OUT
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.QuarticEaseInOut(System.Double)">
            <summary>
            QUARTIC EASE IN/OUT
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.QuarticEaseOutIn(System.Double)">
            <summary>
            QUARTIC EASE OUT/IN
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>		
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.QuinticEaseIn(System.Double)">
            <summary>
            QUINTYIC EASE IN
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.QuinticEaseOut(System.Double)">
            <summary>
            QUINTYIC EASE OUT
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.QuinticEaseInOut(System.Double)">
            <summary>
            QUINTYIC EASE IN/OUT
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.QuinticEaseOutIn(System.Double)">
            <summary>
            QUINTYIC EASE OUT/IN
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.SinusoidalEaseIn(System.Double)">
            <summary>
            SINUSOIDAL EASE IN
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.SinusoidalEaseOut(System.Double)">
            <summary>
            SINUSOIDAL EASE OUT
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.SinusoidalEaseInOut(System.Double)">
            <summary>
            SINUSOIDAL EASE IN/OUT
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.SinusoidalEaseOutIn(System.Double)">
            <summary>
            SINUSOIDAL EASE OUT/IN
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.ExponentialEaseIn(System.Double)">
            <summary>
            EXPONENTIAL EASE IN
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.ExponentialEaseOut(System.Double)">
            <summary>
            EXPONENTIAL EASE OUT
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.ExponentialEaseInOut(System.Double)">
            <summary>
            EXPONENTIAL EASE IN/OUT
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.ExponentialEaseOutIn(System.Double)">
            <summary>
            EXPONENTIAL EASE OUT/IN
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.CircularEaseIn(System.Double)">
            <summary>
            CIRCULAR EASE IN
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.CircularEaseOut(System.Double)">
            <summary>
            CIRCULAR EASE OUT
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.CircularEaseInOut(System.Double)">
            <summary>
            CIRCULAR EASE IN/OUT
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.CircularEaseOutIn(System.Double)">
            <summary>
            CIRCULAR EASE OUT/IN
            </summary>
            <param name="X">Value in the range [0..1]</param>	
            <returns>Shaped value</returns>			
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.ElasticEaseIn(System.Double)">
            <summary>
            ELASTIC EASE IN
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.ElasticEaseOut(System.Double)">
            <summary>
            ELASTIC EASE OUT
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.ElasticEaseInOut(System.Double)">
            <summary>
            ELASTIC EASE IN/OUT
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.ElasticEaseOutIn(System.Double)">
            <summary>
            ELASTIC EASE OUT/IN
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.BackEaseIn(System.Double)">
            <summary>
            BACK EASE IN
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.BackEaseOut(System.Double)">
            <summary>
            BACK EASE OUT
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.BackEaseInOut(System.Double)">
            <summary>
            BACK EASE IN/OUT
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.BackEaseOutIn(System.Double)">
            <summary>
            BACK EASE OUT/IN
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.BounceEaseIn(System.Double)">
            <summary>
            BOUNCE EASE IN
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.BounceEaseOut(System.Double)">
            <summary>
            BOUNCE EASE OUT
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.BounceEaseInOut(System.Double)">
            <summary>
            BOUNCE EASE IN/OUT
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Tweener.BounceEaseOutIn(System.Double)">
            <summary>
            BOUNCE EASE OUT/IN
            </summary>
            <param name="X">Value in the range [0..1]</param>
            <returns>Shaped value</returns>
        </member>
        <member name="T:VVVV.Utils.VMath.Vector2D">
            <summary>
            Fast 2d vector struct with operators
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Vector2D.x">
            <summary>
            Data component for the x dimension
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Vector2D.y">
            <summary>
            Data component for the y dimension
            </summary>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.#ctor(VVVV.Utils.VMath.Vector2D)">
            <summary>
            Copies a 2d-vecor
            </summary>
            <param name="v">Vector to copy</param>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.#ctor(System.Double,System.Double)">
            <summary>
            Makes a 2d-vector from 2 values
            </summary>
            <param name="x">x component of output vector</param>
            <param name="y">y component of output vector</param>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.#ctor(System.Double)">
            <summary>
            Makes a 2d-vector from 1 value, all vector components are set to the input value
            </summary>
            <param name="a">Value for vector components</param>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_UnaryPlus(VVVV.Utils.VMath.Vector2D)">
            <summary>
            + vector, makes no changes to a vector
            </summary>
            <param name="v"></param>
            <returns>Input vector v unchanged</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_UnaryNegation(VVVV.Utils.VMath.Vector2D)">
            <summary>
            - vector, flips the sign off all vector components
            </summary>
            <param name="v"></param>
            <returns>New vector with all components of v negatived</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_LogicalNot(VVVV.Utils.VMath.Vector2D)">
            <summary>
            ! vector, calculates the length of the vector
            </summary>
            <param name="v"></param>
            <returns>Length of input vector v</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_OnesComplement(VVVV.Utils.VMath.Vector2D)">
            <summary>
            ~ vector, normalizes a vector
            </summary>
            <param name="v"></param>
            <returns>Vector with same direction than v but length 1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_Addition(VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D)">
            <summary>
            vector + vector, adds the values of two vectors component wise
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>New vector with the pair wise sum of the components of v1 and v2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_Addition(VVVV.Utils.VMath.Vector2D,System.Double)">
            <summary>
            vector + value, adds a value to all vector components
            </summary>
            <param name="v1"></param>
            <param name="a"></param>
            <returns>New vector with a added to all components of v1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_Addition(System.Double,VVVV.Utils.VMath.Vector2D)">
            <summary>
            value + vector, adds a value to all vector components
            </summary>
            <param name="v1"></param>
            <param name="a"></param>
            <returns>New vector with a added to all components of v1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_Subtraction(VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D)">
            <summary>
            vector - vector, subtracts the components of v2 from the components of v1
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>New vector with the pair wise difference of the components of v1 and v2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_Subtraction(VVVV.Utils.VMath.Vector2D,System.Double)">
            <summary>
            vector - value, subtracts a value from all vector components
            </summary>
            <param name="v1"></param>
            <param name="a"></param>
            <returns>New vector with a subtracted from all components of v1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_Subtraction(System.Double,VVVV.Utils.VMath.Vector2D)">
            <summary>
            value - vector, subtracts all vector components from a value
            </summary>
            <param name="v1"></param>
            <param name="a"></param>
            <returns>New vector with all components of v1 subtracted from a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_Multiply(VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D)">
            <summary>
            vector * vector, multiplies the values of two vectors component wise
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>New vector with the pair wise product of the components of v1 and v2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_Multiply(VVVV.Utils.VMath.Vector2D,System.Double)">
            <summary>
            vector * value, multiplies a value by all vector components
            </summary>
            <param name="v1"></param>
            <param name="a"></param>
            <returns>New vector with all components of v1 multiplied by a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_Multiply(System.Double,VVVV.Utils.VMath.Vector2D)">
            <summary>
            value * vector, multiplies a value by all vector components
            </summary>
            <param name="a"></param>
            <param name="v1"></param>
            <returns>New vector with all components of v1 multiplied by a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_Division(VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D)">
            <summary>
            vector / vector, divides the values of two vectors component wise
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>New vector with components of v1 divided by components of v2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_Division(VVVV.Utils.VMath.Vector2D,System.Double)">
            <summary>
            vector / value, divides all vector components by a value 
            </summary>
            <param name="v1"></param>
            <param name="a"></param>
            <returns>New vector with all components of v1 divided by a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_Division(System.Double,VVVV.Utils.VMath.Vector2D)">
            <summary>
            value / vector, divides a value by all vector components
            </summary>
            <param name="a"></param>
            <param name="v1"></param>
            <returns>New vector with a divided by all components of v1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_Modulus(VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D)">
            <summary>
            vector % vector, component wise modulo for vectors
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>New vector with components of v1 modulo components of v2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_Modulus(VVVV.Utils.VMath.Vector2D,System.Double)">
            <summary>
            vector % value, all vector components modulo a value
            </summary>
            <param name="v1"></param>
            <param name="a"></param>
            <returns>New vector with components of v1 modulo a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_Modulus(System.Double,VVVV.Utils.VMath.Vector2D)">
            <summary>
            value % vector, a value modulo all vector components
            </summary>
            <param name="a"></param>
            <param name="v1"></param>
            <returns>New vector with input a modulo components of v1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_BitwiseAnd(VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D)">
            <summary>
            2d-vector &amp; 2d-vector, performs a 2d-cross product,
            this is the signed size of the parallelogram spanned by v1 and v2.
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>Scalar cross product of v1 and v2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_BitwiseOr(VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D)">
            <summary>
            vector | vector, dot product for vectors, that is the sum of all component wise products
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>Dot product of v1 and v2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_GreaterThan(VVVV.Utils.VMath.Vector2D,System.Double)">
            <summary>
            vector &gt; value, compares all vector components to a value
            </summary>
            <param name="v"></param>
            <param name="a"></param>
            <returns>true, if all components of v are greater than a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_LessThan(VVVV.Utils.VMath.Vector2D,System.Double)">
            <summary>
            vector &lt; value, compares all vector components to a value
            </summary>
            <param name="v"></param>
            <param name="a"></param>
            <returns>true, if all components of v are smaller than a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_GreaterThanOrEqual(VVVV.Utils.VMath.Vector2D,System.Double)">
            <summary>
            vector &gt;= value, compares all vector components to a value
            </summary>
            <param name="v"></param>
            <param name="a"></param>
            <returns>true, if all components of v are greater or equal to a</returns> 
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_LessThanOrEqual(VVVV.Utils.VMath.Vector2D,System.Double)">
            <summary>
            vector &lt;= value, compares all vector components to a value
            </summary>
            <param name="v"></param>
            <param name="a"></param>
            <returns>true, if all components of v are smaller or equal to a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_Equality(VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D)">
            <summary>
            vector == vector, checks if the two vectors are equal
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>true, if all components of v1 equal the components of v2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector2D.op_Inequality(VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D)">
            <summary>
            vector != vector, checks if the two vectors are not equal
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>true, if any component of v1 is different from the components of v2</returns>
        </member>
        <member name="P:VVVV.Utils.VMath.Vector2D.Length">
            <summary>
            Get or Set the Length of this vector
            </summary>
        </member>
        <member name="P:VVVV.Utils.VMath.Vector2D.Item(System.Int32)">
            <summary>
            Unsafe but very fast indexer for 2d-vector, [0..1]
            </summary>
        </member>
        <member name="T:VVVV.Utils.VMath.Vector3D">
            <summary>
            Fast 3d vector struct with operators
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Vector3D.x">
            <summary>
            Data component for the x dimension
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Vector3D.y">
            <summary>
            Data component for the y dimension
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Vector3D.z">
            <summary>
            Data component for the z dimension
            </summary>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.#ctor(VVVV.Utils.VMath.Vector3D)">
            <summary>
            Copies a 3d-vecor
            </summary>
            <param name="v">Vector to copy</param>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.#ctor(VVVV.Utils.VMath.Vector2D)">
            <summary>
            Makes a 3d-vector copy from a 2d-vector, z is set to 0
            </summary>
            <param name="v">2d-vector to copy</param>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.#ctor(VVVV.Utils.VMath.Vector2D,System.Double)">
            <summary>
            Makes a 3d-vector copy from a 2d-vector and z component
            </summary>
            <param name="v">2d-vector to copy</param>
            <param name="z">z component of output vector</param>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Makes a 3d-vector from 3 values
            </summary>
            <param name="x">x component of output vector</param>
            <param name="y">y component of output vector</param>
            <param name="z">z component of output vector</param>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.#ctor(System.Double)">
            <summary>
            Makes a 3d-vector from 1 value, all vector components are set to the input value
            </summary>
            <param name="a">Value for vector components</param>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_UnaryPlus(VVVV.Utils.VMath.Vector3D)">
            <summary>
            + vector, makes no changes to a vector
            </summary>
            <param name="v"></param>
            <returns>Input vector v unchanged</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_UnaryNegation(VVVV.Utils.VMath.Vector3D)">
            <summary>
            - vector, flips the sign off all vector components
            </summary>
            <param name="v"></param>
            <returns>New vector with all components of v negatived</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_LogicalNot(VVVV.Utils.VMath.Vector3D)">
            <summary>
            ! vector, calculates the length of the vector
            </summary>
            <param name="v"></param>
            <returns>Length of input vector v</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_OnesComplement(VVVV.Utils.VMath.Vector3D)">
            <summary>
            ~ vector, normalizes a vector
            </summary>
            <param name="v"></param>
            <returns>Vector with same direction than v but length 1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_Addition(VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D)">
            <summary>
            vector + vector, adds the values of two vectors component wise
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>New vector with the pair wise sum of the components of v1 and v2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_Addition(VVVV.Utils.VMath.Vector3D,System.Double)">
            <summary>
            vector + value, adds a value to all vector components
            </summary>
            <param name="v1"></param>
            <param name="a"></param>
            <returns>New vector with a added to all components of v1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_Addition(System.Double,VVVV.Utils.VMath.Vector3D)">
            <summary>
            value + vector, adds a value to all vector components
            </summary>
            <param name="v1"></param>
            <param name="a"></param>
            <returns>New vector with a added to all components of v1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_Subtraction(VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D)">
            <summary>
            vector - vector, subtracts the components of v2 from the components of v1
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>New vector with the pair wise difference of the components of v1 and v2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_Subtraction(VVVV.Utils.VMath.Vector3D,System.Double)">
            <summary>
            vector - value, subtracts a value from all vector components
            </summary>
            <param name="v1"></param>
            <param name="a"></param>
            <returns>New vector with a subtracted from all components of v1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_Subtraction(System.Double,VVVV.Utils.VMath.Vector3D)">
            <summary>
            value - vector, subtracts all vector components from a value
            </summary>
            <param name="v1"></param>
            <param name="a"></param>
            <returns>New vector with all components of v1 subtracted from a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_Multiply(VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D)">
            <summary>
            vector * vector, multiplies the values of two vectors component wise
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>New vector with the pair wise product of the components of v1 and v2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_Multiply(VVVV.Utils.VMath.Vector3D,System.Double)">
            <summary>
            vector * value, multiplies a value by all vector components
            </summary>
            <param name="v1"></param>
            <param name="a"></param>
            <returns>New vector with all components of v1 multiplied by a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_Multiply(System.Double,VVVV.Utils.VMath.Vector3D)">
            <summary>
            value * vector, multiplies a value by all vector components
            </summary>
            <param name="a"></param>
            <param name="v1"></param>
            <returns>New vector with all components of v1 multiplied by a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_Division(VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D)">
            <summary>
            vector / vector, divides the values of two vectors component wise
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>New vector with components of v1 divided by components of v2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_Division(VVVV.Utils.VMath.Vector3D,System.Double)">
            <summary>
            vector / value, divides all vector components by a value 
            </summary>
            <param name="v1"></param>
            <param name="a"></param>
            <returns>New vector with all components of v1 divided by a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_Division(System.Double,VVVV.Utils.VMath.Vector3D)">
            <summary>
            value / vector, divides a value by all vector components
            </summary>
            <param name="a"></param>
            <param name="v1"></param>
            <returns>New vector with a divided by all components of v1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_Modulus(VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D)">
            <summary>
            vector % vector, component wise modulo for vectors
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>New vector with components of v1 modulo components of v2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_Modulus(VVVV.Utils.VMath.Vector3D,System.Double)">
            <summary>
            vector % value, all vector components modulo a value
            </summary>
            <param name="v1"></param>
            <param name="a"></param>
            <returns>New vector with components of v1 modulo a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_Modulus(System.Double,VVVV.Utils.VMath.Vector3D)">
            <summary>
            value % vector, a value modulo all vector components
            </summary>
            <param name="a"></param>
            <param name="v1"></param>
            <returns>New vector with input a modulo components of v1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_BitwiseAnd(VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D)">
            <summary>
            3d-vector &amp; 3d-vector, performs a 3d cross product
            
            code is:
            <c>
            x = v1.y * v2.z - v1.z * v2.y
            y = v1.z * v2.x - v1.x * v2.y
            z = v1.x * v2.y - v1.y * v2.x
            </c>
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>New vector which is orthogonal to v1 and v2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_BitwiseOr(VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D)">
            <summary>
            vector | vector, dot product for vectors, that is the sum of all component wise products
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>Dot product of v1 and v2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_GreaterThan(VVVV.Utils.VMath.Vector3D,System.Double)">
            <summary>
            vector &gt; value, compares all vector components to a value
            </summary>
            <param name="v"></param>
            <param name="a"></param>
            <returns>true, if all components of v are greater than a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_LessThan(VVVV.Utils.VMath.Vector3D,System.Double)">
            <summary>
            vector &lt; value, compares all vector components to a value
            </summary>
            <param name="v"></param>
            <param name="a"></param>
            <returns>true, if all components of v are smaller than a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_GreaterThanOrEqual(VVVV.Utils.VMath.Vector3D,System.Double)">
            <summary>
            vector &gt;= value, compares all vector components to a value
            </summary>
            <param name="v"></param>
            <param name="a"></param>
            <returns>true, if all components of v are greater or equal to a</returns> 
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_LessThanOrEqual(VVVV.Utils.VMath.Vector3D,System.Double)">
            <summary>
            vector &lt;= value, compares all vector components to a value
            </summary>
            <param name="v"></param>
            <param name="a"></param>
            <returns>true, if all components of v are smaller or equal to a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_Equality(VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D)">
            <summary>
            vector == vector, checks if the two vectors are equal
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>true, if all components of v1 equal the components of v2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector3D.op_Inequality(VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D)">
            <summary>
            vector != vector, checks if the two vectors are not equal
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>true, if any component of v1 is different from the components of v2</returns>
        </member>
        <member name="P:VVVV.Utils.VMath.Vector3D.Length">
            <summary>
            Get or Set the Length of this vector
            </summary>
        </member>
        <member name="P:VVVV.Utils.VMath.Vector3D.xy">
            <summary>
            Get/set x and y components as 2d-vector
            </summary>
        </member>
        <member name="P:VVVV.Utils.VMath.Vector3D.xz">
            <summary>
            Get/set x and z components as 2d-vector
            </summary>
        </member>
        <member name="P:VVVV.Utils.VMath.Vector3D.yz">
            <summary>
            Get/set y and z components as 2d-vector
            </summary>
        </member>
        <member name="P:VVVV.Utils.VMath.Vector3D.Item(System.Int32)">
            <summary>
            Unsafe but very fast indexer for 3d-vector, [0..2]
            </summary>
        </member>
        <member name="T:VVVV.Utils.VMath.Vector4D">
            <summary>
            Fast 4d vector struct with operators
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Vector4D.x">
            <summary>
            Data component for the x dimension
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Vector4D.y">
            <summary>
            Data component for the y dimension
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Vector4D.z">
            <summary>
            Data component for the z dimension
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.Vector4D.w">
            <summary>
            Data component for the w dimension
            </summary>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.#ctor(VVVV.Utils.VMath.Vector4D)">
            <summary>
            Copies a 4d-vecor
            </summary>
            <param name="v">Vector to copy</param>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.#ctor(VVVV.Utils.VMath.Vector3D)">
            <summary>
            Makes a 4d-vector copy from a 3d-vector, w is set to 1
            </summary>
            <param name="v">3d-vector to copy</param>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.#ctor(VVVV.Utils.VMath.Vector3D,System.Double)">
            <summary>
            Makes a 4d-vector copy from a 3d-vector and w component
            </summary>
            <param name="v">3d-vector to copy</param>
            <param name="w">w component of output vector</param>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.#ctor(VVVV.Utils.VMath.Vector2D)">
            <summary>
            Makes a 4d-vector copy from a 2d-vector, z is set to 0 and w to 1
            </summary>
            <param name="v">2d-vector to copy</param>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.#ctor(VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D)">
            <summary>
            Makes a 4d-vector copy from a two 2d-vectors
            </summary>
            <param name="v1">2d-vector for x and y</param>
            <param name="v2">2d-vector for z and w</param>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.#ctor(VVVV.Utils.VMath.Vector2D,System.Double,System.Double)">
            <summary>
            Makes a 4d-vector copy from a 2d-vector and z and w component
            </summary>
            <param name="v">2d-vector to copy</param>
            <param name="z">z component of output vector</param>
            <param name="w">w component of output vector</param>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Makes a 4d-vector from 4 values
            </summary>
            <param name="x">x component of output vector</param>
            <param name="y">y component of output vector</param>
            <param name="z">z component of output vector</param>
            <param name="w">w component of output vector</param>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.#ctor(System.Double)">
            <summary>
            Makes a 4d-vector from 1 value, all vector components are set to the input value
            </summary>
            <param name="a">Value for vector components</param>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_UnaryPlus(VVVV.Utils.VMath.Vector4D)">
            <summary>
            + vector, makes no changes to a vector
            </summary>
            <param name="v"></param>
            <returns>Input vector v unchanged</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_UnaryNegation(VVVV.Utils.VMath.Vector4D)">
            <summary>
            - vector, flips the sign off all vector components
            </summary>
            <param name="v"></param>
            <returns>New vector with all components of v negatived</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_LogicalNot(VVVV.Utils.VMath.Vector4D)">
            <summary>
            ! vector, calculates the length of the vector
            </summary>
            <param name="v"></param>
            <returns>Length of input vector v</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_OnesComplement(VVVV.Utils.VMath.Vector4D)">
            <summary>
            ~ vector, normalizes a vector
            </summary>
            <param name="v"></param>
            <returns>Vector with same direction than v but length 1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_Addition(VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D)">
            <summary>
            vector + vector, adds the values of two vectors component wise
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>New vector with the pair wise sum of the components of v1 and v2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_Addition(VVVV.Utils.VMath.Vector4D,System.Double)">
            <summary>
            vector + value, adds a value to all vector components
            </summary>
            <param name="v1"></param>
            <param name="a"></param>
            <returns>New vector with a added to all components of v1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_Addition(System.Double,VVVV.Utils.VMath.Vector4D)">
            <summary>
            value + vector, adds a value to all vector components
            </summary>
            <param name="v1"></param>
            <param name="a"></param>
            <returns>New vector with a added to all components of v1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_Subtraction(VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D)">
            <summary>
            vector - vector, subtracts the components of v2 from the components of v1
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>New vector with the pair wise difference of the components of v1 and v2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_Subtraction(VVVV.Utils.VMath.Vector4D,System.Double)">
            <summary>
            vector - value, subtracts a value from all vector components
            </summary>
            <param name="v1"></param>
            <param name="a"></param>
            <returns>New vector with a subtracted from all components of v1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_Subtraction(System.Double,VVVV.Utils.VMath.Vector4D)">
            <summary>
            value - vector, subtracts all vector components from a value
            </summary>
            <param name="v1"></param>
            <param name="a"></param>
            <returns>New vector with all components of v1 subtracted from a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_Multiply(VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D)">
            <summary>
            vector * vector, multiplies the values of two vectors component wise
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>New vector with the pair wise product of the components of v1 and v2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_Multiply(VVVV.Utils.VMath.Vector4D,System.Double)">
            <summary>
            vector * value, multiplies a value by all vector components
            </summary>
            <param name="v1"></param>
            <param name="a"></param>
            <returns>New vector with all components of v1 multiplied by a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_Multiply(System.Double,VVVV.Utils.VMath.Vector4D)">
            <summary>
            value * vector, multiplies a value by all vector components
            </summary>
            <param name="a"></param>
            <param name="v1"></param>
            <returns>New vector with all components of v1 multiplied by a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_Division(VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D)">
            <summary>
            vector / vector, divides the values of two vectors component wise
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>New vector with components of v1 divided by components of v2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_Division(VVVV.Utils.VMath.Vector4D,System.Double)">
            <summary>
            vector / value, divides all vector components by a value 
            </summary>
            <param name="v1"></param>
            <param name="a"></param>
            <returns>New vector with all components of v1 divided by a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_Division(System.Double,VVVV.Utils.VMath.Vector4D)">
            <summary>
            value / vector, divides a value by all vector components
            </summary>
            <param name="a"></param>
            <param name="v1"></param>
            <returns>New vector with a divided by all components of v1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_Modulus(VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D)">
            <summary>
            vector % vector, component wise modulo for vectors
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>New vector with components of v1 modulo components of v2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_Modulus(VVVV.Utils.VMath.Vector4D,System.Double)">
            <summary>
            vector % value, all vector components modulo a value
            </summary>
            <param name="v1"></param>
            <param name="a"></param>
            <returns>New vector with components of v1 modulo a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_Modulus(System.Double,VVVV.Utils.VMath.Vector4D)">
            <summary>
            value % vector, a value modulo all vector components
            </summary>
            <param name="a"></param>
            <param name="v1"></param>
            <returns>New vector with input a modulo components of v1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_BitwiseAnd(VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D)">
             <summary>
             4d-vector &amp; 4d-vector, performs a quaternion multiplication
             
             defined as:
            	w = v1.w * v2.w - (v1.xyz | v2.xyz)
            	xyz = v1.xyz * v2.w + v2.xyz * v1.w + (v1.xyz &amp; v2.xyz)
            
             code is:
             <c>
             x = v1.w*v2.x + v1.x*v2.w + v1.y*v2.z - v1.z*v2.y
            	y = v1.w*v2.y + v1.y*v2.w + v1.z*v2.x - v1.x*v2.z
            	z = v1.w*v2.z + v1.z*v2.w + v1.x*v2.y - v1.y*v2.x
            	w = v1.w*v2.w - v1.x*v2.x - v1.y*v2.y - v1.z*v2.z
             </c>
             </summary>
             <param name="v1"></param>
             <param name="v2"></param>
             <returns>Quaternion v1 multiplied by quaternion v2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_BitwiseOr(VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D)">
            <summary>
            vector | vector, dot product for vectors, that is the sum of all component wise products
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>Dot product of v1 and v2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_GreaterThan(VVVV.Utils.VMath.Vector4D,System.Double)">
            <summary>
            vector &gt; value, compares all vector components to a value
            </summary>
            <param name="v"></param>
            <param name="a"></param>
            <returns>true, if all components of v are greater than a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_LessThan(VVVV.Utils.VMath.Vector4D,System.Double)">
            <summary>
            vector &lt; value, compares all vector components to a value
            </summary>
            <param name="v"></param>
            <param name="a"></param>
            <returns>true, if all components of v are smaller than a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_GreaterThanOrEqual(VVVV.Utils.VMath.Vector4D,System.Double)">
            <summary>
            vector &gt;= value, compares all vector components to a value
            </summary>
            <param name="v"></param>
            <param name="a"></param>
            <returns>true, if all components of v are greater or equal to a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_LessThanOrEqual(VVVV.Utils.VMath.Vector4D,System.Double)">
            <summary>
            vector &lt;= value, compares all vector components to a value
            </summary>
            <param name="v"></param>
            <param name="a"></param>
            <returns>true, if all components of v are smaller or equal to a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_Equality(VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D)">
            <summary>
            vector == vector, checks if the two vectors are equal
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>true, if all components of v1 equal the components of v2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.Vector4D.op_Inequality(VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D)">
            <summary>
            vector != vector, checks if the two vectors are not equal
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns>true, if any component of v1 is different from the components of v2</returns>
        </member>
        <member name="P:VVVV.Utils.VMath.Vector4D.Length">
            <summary>
            Get or Set the Length of this vector
            </summary>
        </member>
        <member name="P:VVVV.Utils.VMath.Vector4D.xy">
            <summary>
            Get/set x and y components as 2d-vector
            </summary>
        </member>
        <member name="P:VVVV.Utils.VMath.Vector4D.xyz">
            <summary>
            Get/set x, y and z components as 3d-vector
            </summary>
        </member>
        <member name="P:VVVV.Utils.VMath.Vector4D.Item(System.Int32)">
            <summary>
            Unsafe but very fast indexer for 4d-vector, [0..3]
            </summary>
        </member>
        <member name="T:VVVV.Utils.VMath.TMapMode">
            <summary>
            vvvv like modi for the Map function
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.TMapMode.Float">
            <summary>
            Maps the value continously
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.TMapMode.Clamp">
            <summary>
            Maps the value, but clamps it at the min/max borders of the output range
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.TMapMode.Wrap">
            <summary>
            Maps the value, but repeats it into the min/max range, like a modulo function
            </summary>
        </member>
        <member name="T:VVVV.Utils.VMath.VMath">
            <summary>
            The vvvv c# math routines library
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.VMath.Pi">
            <summary>
            Pi, as you know it
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.VMath.TwoPi">
            <summary>
            Pi * 2
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.VMath.PiRez">
            <summary>
            1 / Pi, multiply by this if you have to divide by Pi
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.VMath.TwoPiRez">
            <summary>
            2 / Pi, multiply by this if you have to divide by 2*Pi
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.VMath.CycToRad">
            <summary>
            Conversion factor from cycles to radians, (2 * Pi)
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.VMath.RadToCyc">
            <summary>
            Conversion factor from radians to cycles, 1/(2 * Pi)
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.VMath.DegToRad">
            <summary>
            Conversion factor from degree to radians, (2 * Pi)/360
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.VMath.RadToDeg">
            <summary>
            Conversion factor from radians to degree, 360/(2 * Pi)
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.VMath.DegToCyc">
            <summary>
            Conversion factor from degree to radians, 1/360
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.VMath.CycToDeg">
            <summary>
            Conversion factor from radians to degree, 360
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.VMath.IdentityMatrix">
            <summary>
            Identity matrix 
            1000 
            0100
            0010
            0001
            </summary>
        </member>
        <member name="F:VVVV.Utils.VMath.VMath.Random">
            <summary>
            A random object for conveninece
            </summary>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.RandomVector2D">
            <summary>
            Creates a random 2d vector.
            </summary>
            <returns>Random vector with its components in the range [-1..1].</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.RandomVector3D">
            <summary>
            Creates a random 3d vector.
            </summary>
            <returns>Random vector with its components in the range [-1..1].</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.RandomVector4D">
            <summary>
            Creates a random 4d vector.
            </summary>
            <returns>Random vector with its components in the range [-1..1].</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Factorial(System.Int32)">
            <summary>
            Factorial function
            </summary>
            <param name="n"></param>
            <returns>The product n * n-1 * n-2 * n-3 * .. * 3 * 2 * 1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Binomial(System.Int32,System.Int32)">
            <summary>
            Binomial function
            </summary>
            <param name="n"></param>
            <param name="k"></param>
            <returns>The number of k-tuples of n items</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Min(System.Double,System.Double)">
            <summary>
            Min function
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>Smaller value of the two input parameters</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Max(System.Double,System.Double)">
            <summary>
            Max function
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>Greater value of the two input parameters</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Zmod(System.Int32,System.Int32)">
            <summary>
            Modulo function with the property, that the remainder of a division z / d
            and z &lt; 0 is positive. For example: zmod(-2, 30) = 28.
            </summary>
            <param name="z"></param>
            <param name="d"></param>
            <returns>Remainder of division z / d.</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Clamp(System.Double,System.Double,System.Double)">
            <summary>
            Clamp function, clamps a floating point value into the range [min..max]
            </summary>
            <param name="x"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Clamp(System.Int32,System.Int32,System.Int32)">
            <summary>
            Clamp function, clamps an integer value into the range [min..max]
            </summary>
            <param name="x"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Clamp(VVVV.Utils.VMath.Vector2D,System.Double,System.Double)">
            <summary>
            Clamp function, clamps a 2d-vector into the range [min..max]
            </summary>
            <param name="v"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Clamp(VVVV.Utils.VMath.Vector3D,System.Double,System.Double)">
            <summary>
            Clamp function, clamps a 3d-vector into the range [min..max]
            </summary>
            <param name="v"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Clamp(VVVV.Utils.VMath.Vector4D,System.Double,System.Double)">
            <summary>
            Clamp function, clamps a 4d-vector into the range [min..max]
            </summary>
            <param name="v"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Clamp(VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D)">
            <summary>
            Clamp function, clamps a 2d-vector into the range [min..max]
            </summary>
            <param name="v"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Clamp(VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D)">
            <summary>
            Clamp function, clamps a 3d-vector into the range [min..max]
            </summary>
            <param name="v"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Clamp(VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D)">
            <summary>
            Clamp function, clamps a 4d-vector into the range [min..max]
            </summary>
            <param name="v"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Abs(System.Double)">
            <summary>
            Abs function for values, just for completeness
            </summary>
            <param name="a"></param>
            <returns>New value with the absolut value of a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Abs(VVVV.Utils.VMath.Vector2D)">
            <summary>
            Abs function for 2d-vectors
            </summary>
            <param name="a"></param>
            <returns>New vector with the absolut values of the components of input vector a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Abs(VVVV.Utils.VMath.Vector3D)">
            <summary>
            Abs function for 3d-vectors
            </summary>
            <param name="a"></param>
            <returns>New vector with the absolut values of the components of input vector a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Abs(VVVV.Utils.VMath.Vector4D)">
            <summary>
            Abs function for 4d-vectors
            </summary>
            <param name="a"></param>
            <returns>New vector with the absolut values of the components of input vector a</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Dist(System.Double,System.Double)">
            <summary>
            Calculates the distance between two values
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns>Positive distance between p1 and p2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Dist(VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D)">
            <summary>
            Calculates the distance between two 2d-points
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns>Positive distance between p1 and p2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Dist(VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D)">
            <summary>
            Calculates the distance between two 3d-points
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns>Positive distance between p1 and p2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Dist(VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D)">
            <summary>
            Calculates the distance between two 4d-points
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns>Positive distance between p1 and p2</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Map(System.Double,System.Double,System.Double,System.Double,System.Double,VVVV.Utils.VMath.TMapMode)">
            <summary>
            The infamous Map function of vvvv for values
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VVVV.Utils.VMath.TMapMode">TMapMode</see></param>
            <returns>Input value mapped from input range into destination range</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Map(VVVV.Utils.VMath.Vector2D,System.Double,System.Double,System.Double,System.Double,VVVV.Utils.VMath.TMapMode)">
            <summary>
            The infamous Map function of vvvv for 2d-vectors and value range bounds
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VVVV.Utils.VMath.TMapMode">TMapMode</see></param>
            <returns>Input vector mapped from input range into destination range</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Map(VVVV.Utils.VMath.Vector3D,System.Double,System.Double,System.Double,System.Double,VVVV.Utils.VMath.TMapMode)">
            <summary>
            The infamous Map function of vvvv for 3d-vectors and value range bounds
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VVVV.Utils.VMath.TMapMode">TMapMode</see></param>
            <returns>Input vector mapped from input range into destination range</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Map(VVVV.Utils.VMath.Vector4D,System.Double,System.Double,System.Double,System.Double,VVVV.Utils.VMath.TMapMode)">
            <summary>
            The infamous Map function of vvvv for 4d-vectors and value range bounds
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VVVV.Utils.VMath.TMapMode">TMapMode</see></param>
            <returns>Input vector mapped from input range into destination range</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Map(VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.TMapMode)">
            <summary>
            The infamous Map function of vvvv for 2d-vectors and range bounds given as vectors
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VVVV.Utils.VMath.TMapMode">TMapMode</see></param>
            <returns>Input vector mapped from input range into destination range</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Map(VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.TMapMode)">
            <summary>
            The infamous Map function of vvvv for 3d-vectors and range bounds given as vectors
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VVVV.Utils.VMath.TMapMode">TMapMode</see></param>
            <returns>Input vector mapped from input range into destination range</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Map(VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.TMapMode)">
            <summary>
            The infamous Map function of vvvv for 4d-vectors and range bounds given as vectors
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VVVV.Utils.VMath.TMapMode">TMapMode</see></param>
            <returns>Input vector mapped from input range into destination range</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Lerp(System.Double,System.Double,System.Double)">
            <summary>
            Linear interpolation (blending) between two values
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="x"></param>
            <returns>Linear interpolation between a and b if x in the range ]0..1[ or a if x = 0 or b if x = 1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Lerp(VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D,System.Double)">
            <summary>
            Linear interpolation (blending) between two 2d-vectors
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="x"></param>
            <returns>Linear interpolation between a and b if x in the range ]0..1[, or a if x = 0, or b if x = 1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Lerp(VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D,System.Double)">
            <summary>
            Linear interpolation (blending) between two 3d-vectors
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="x"></param>
            <returns>Linear interpolation between a and b if x in the range ]0..1[, or a if x = 0, or b if x = 1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Lerp(VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D,System.Double)">
            <summary>
            Linear interpolation (blending) between two 4d-vectors
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="x"></param>
            <returns>Linear interpolation between a and b if x in the range ]0..1[, or a if x = 0, or b if x = 1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Bilerp(VVVV.Utils.VMath.Vector2D,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            2d linear interpolation in x and y direction for single values
            </summary>
            <param name="Input">The position where to interpolate, 0..1</param>
            <param name="P1">Upper left value</param>
            <param name="P2">Upper right value</param>
            <param name="P3">Lower right value</param>
            <param name="P4">Lower left value</param>
            <returns>Interpolated value between the 4 values of the corners of a unit square</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Bilerp(VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D)">
            <summary>
            2d linear interpolation in x and y direction for 2d-vectors
            </summary>
            <param name="Input">The position where to interpolate, 0..1</param>
            <param name="P1">Upper left vector</param>
            <param name="P2">Upper right vector</param>
            <param name="P3">Lower right vector</param>
            <param name="P4">Lower left vector</param>
            <returns>Interpolated vector between the 4 vectors of the corners of a unit square</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Bilerp(VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D)">
            <summary>
            2d linear interpolation in x and y direction for 3d-vectors
            </summary>
            <param name="Input">The position where to interpolate, 0..1</param>
            <param name="P1">Upper left vector</param>
            <param name="P2">Upper right vector</param>
            <param name="P3">Lower right vector</param>
            <param name="P4">Lower left vector</param>
            <returns>Interpolated vector between the 4 vectors of the corners of a unit square</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Bilerp(VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D)">
            <summary>
            2d linear interpolation in x and y direction for 4d-vectors
            </summary>
            <param name="Input">The position where to interpolate, 0..1</param>
            <param name="P1">Upper left vector</param>
            <param name="P2">Upper right vector</param>
            <param name="P3">Lower right vector</param>
            <param name="P4">Lower left vector</param>
            <returns>Interpolated vector between the 4 vectors of the corners of a unit square</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Trilerp(VVVV.Utils.VMath.Vector3D,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            3d linear interpolation in x, y and z direction for single values
            </summary>
            <param name="Input">The Interpolation factor, 3d-position inside the unit cube</param>
            <param name="V010">Front upper left</param>
            <param name="V110">Front upper right</param>
            <param name="V100">Front lower right</param>
            <param name="V000">Front lower left</param>
            <param name="V011">Back upper left</param>
            <param name="V111">Back upper right</param>
            <param name="V101">Back lower right</param>
            <param name="V001">Back lower left</param>
            <returns>Interpolated value between the 8 values of the corners of a unit cube</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Trilerp(VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D,VVVV.Utils.VMath.Vector2D)">
            <summary>
            3d linear interpolation in x, y and z direction for 2d-vectors
            </summary>
            <param name="Input">The Interpolation factor, 3d-position inside the unit cube</param>
            <param name="V010">Front upper left</param>
            <param name="V110">Front upper right</param>
            <param name="V100">Front lower right</param>
            <param name="V000">Front lower left</param>
            <param name="V011">Back upper left</param>
            <param name="V111">Back upper right</param>
            <param name="V101">Back lower right</param>
            <param name="V001">Back lower left</param>
            <returns>Interpolated vector between the 8 vectors of the corners of a unit cube</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Trilerp(VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D)">
            <summary>
            3d linear interpolation in x, y and z direction for 3d-vectors
            </summary>
            <param name="Input">The Interpolation factor, 3d-position inside the unit cube</param>
            <param name="V010">Front upper left</param>
            <param name="V110">Front upper right</param>
            <param name="V100">Front lower right</param>
            <param name="V000">Front lower left</param>
            <param name="V011">Back upper left</param>
            <param name="V111">Back upper right</param>
            <param name="V101">Back lower right</param>
            <param name="V001">Back lower left</param>
            <returns>Interpolated vector between the 8 vectors of the corners of a unit cube</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Trilerp(VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D)">
            <summary>
            3d linear interpolation in x, y and z direction for 4d-vectors
            </summary>
            <param name="Input">The Interpolation factor, 3d-position inside the unit cube</param>
            <param name="V010">Front upper left</param>
            <param name="V110">Front upper right</param>
            <param name="V100">Front lower right</param>
            <param name="V000">Front lower left</param>
            <param name="V011">Back upper left</param>
            <param name="V111">Back upper right</param>
            <param name="V101">Back lower right</param>
            <param name="V001">Back lower left</param>
            <returns>Interpolated vector between the 8 vectors of the corners of a unit cube</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.SolveCubic(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Cubic interpolation curve used in the vvvv timeline
            </summary>
            <param name="CurrenTime"></param>
            <param name="Handle0"></param>
            <param name="Handle1"></param>
            <param name="Handle2"></param>
            <param name="Handle3"></param>
            <returns></returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Slerp(VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D,System.Double)">
            <summary>
            Spherical interpolation between two quaternions (4d-vectors)
            The effect is a rotation with uniform angular velocity around a fixed rotation axis from one state of rotation to another
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="x"></param>
            <returns>Spherical interpolation between a and b if x in the range ]0..1[, or a if x = 0, or b if x = 1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Slerp(VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D,System.Double)">
            <summary>
            Spherical interpolation between two points (3d-vectors)
            The effect is a rotation with uniform angular velocity around a fixed rotation axis from one state of rotation to another
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="x"></param>
            <returns>Spherical interpolation between a and b if x in the range ]0..1[, or a if x = 0, or b if x = 1</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Cartesian(System.Double,System.Double,System.Double)">
            <summary>
            Convert polar coordinates (pitch, yaw, lenght) in radian to cartesian coordinates (x, y, z).
            To convert angles from cycles to radian, multiply them with VMath.CycToDec.
            </summary>
            <param name="pitch"></param>
            <param name="yaw"></param>
            <param name="length"></param>
            <returns>3d-point in cartesian coordinates</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Cartesian(VVVV.Utils.VMath.Vector3D)">
            <summary>
            Convert polar coordinates (pitch, yaw, lenght) in radian to cartesian coordinates (x, y, z).
            To convert angles from cycles to radian, multiply them with VMath.CycToDec.
            </summary>
            <param name="polar">3d-vector containing the polar coordinates as (pitch, yaw, length)</param>
            <returns></returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.CartesianVVVV(System.Double,System.Double,System.Double)">
            <summary>
            Convert polar coordinates (pitch, yaw, lenght) in radian to cartesian coordinates (x, y, z) exacly like the vvvv node Cartesian.
            To convert angles from cycles to radian, multiply them with VMath.CycToDec.
            </summary>
            <param name="pitch"></param>
            <param name="yaw"></param>
            <param name="length"></param>
            <returns>3d-point in cartesian coordinates like the vvvv node does it</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.CartesianVVVV(VVVV.Utils.VMath.Vector3D)">
            <summary>
            Convert polar coordinates (pitch, yaw, lenght) in radian to cartesian coordinates (x, y, z) exacly like the vvvv node Cartesian.
            To convert angles from cycles to radian, multiply them with VMath.CycToDec.
            </summary>
            <param name="polar">3d-vector containing the polar coordinates as (pitch, yaw, length)</param>
            <returns></returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Polar(System.Double,System.Double,System.Double)">
            <summary>
            Convert cartesian coordinates (x, y, z) to polar coordinates (pitch, yaw, lenght) in radian.
            To convert the angles to cycles, multiply them with VMath.DegToCyc.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <returns>3d-point in polar coordinates</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Polar(VVVV.Utils.VMath.Vector3D)">
            <summary>
            Convert cartesian coordinates (x, y, z) to polar coordinates (pitch, yaw, lenght) in radian.
            To convert the angles to cycles, multiply them with VMath.DegToCyc.
            </summary>
            <param name="a"></param>
            <returns>Point in polar coordinates</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.PolarVVVV(System.Double,System.Double,System.Double)">
            <summary>
            Convert cartesian coordinates (x, y, z) to VVVV style polar coordinates (pitch, yaw, lenght) in radian.
            To convert the angles to cycles, multiply them with VMath.DegToCyc.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <returns>3d-point in polar coordinates</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.PolarVVVV(VVVV.Utils.VMath.Vector3D)">
            <summary>
            Convert cartesian coordinates (x, y, z) to polar VVVV style coordinates (pitch, yaw, lenght) in radian.
            To convert the angles to cycles, multiply them with VMath.DegToCyc.
            </summary>
            <param name="a"></param>
            <returns>Point in polar coordinates</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.QuaternionToEulerYawPitchRoll(VVVV.Utils.VMath.Vector4D,System.Double@,System.Double@,System.Double@)">
            <summary>
            Converts a quaternion into euler angles, assuming that the euler angle multiplication to create the quaternion was yaw*pitch*roll.
            All angles in radian.
            </summary>
            <param name="q">A quaternion, can be non normalized</param>
            <param name="pitch"></param>
            <param name="yaw"></param>
            <param name="roll"></param>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.QuaternionToEulerYawPitchRoll(VVVV.Utils.VMath.Vector4D)">
            <summary>
            Converts a quaternion into euler angles, assuming that the euler angle multiplication to create the quaternion was yaw*pitch*roll.
            All angles in radian.
            </summary>
            <param name="q">A quaternion, can be non normalized</param>
            <returns>3d-vector with x=pitch, y=yaw, z=roll</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Translate(System.Double,System.Double,System.Double)">
            <summary>
            Creates a translation matrix from 3 given values
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <returns>Translation matrix</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Translate(VVVV.Utils.VMath.Vector3D)">
            <summary>
            Creates a translation matrix from a given 3d-vector
            </summary>
            <param name="v"></param>
            <returns>Translation matrix</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Scale(System.Double,System.Double,System.Double)">
            <summary>
            Creates a scaling matrix from 3 given values
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <returns>Scaling matrix</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Scale(VVVV.Utils.VMath.Vector3D)">
            <summary>
            Creates a scaling matrix from a given 3d-vector
            </summary>
            <param name="v"></param>
            <returns>Scaling matrix</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.RotateX(System.Double)">
            <summary>
            Creates a rotation matrix from a given angle around the x-axis
            </summary>
            <param name="rotX"></param>
            <returns>Rotation matrix</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.RotateY(System.Double)">
            <summary>
            Creates a rotation matrix from a given angle around the y-axis
            </summary>
            <param name="rotY"></param>
            <returns>Rotation matrix</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.RotateZ(System.Double)">
            <summary>
            Creates a rotation matrix from a given angle around the z-axis
            </summary>
            <param name="rotZ"></param>
            <returns>Rotation matrix</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Rotate(System.Double,System.Double,System.Double)">
            <summary>
            Creates a rotation matrix from 3 angles
            </summary>
            <param name="rotX"></param>
            <param name="rotY"></param>
            <param name="rotZ"></param>
            <returns>Rotation matrix</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Rotate(VVVV.Utils.VMath.Vector3D)">
            <summary>
             Creates a rotation matrix from 3 angles given as 3d-vector
            </summary>
            <param name="rot"></param>
            <returns>Rotation matrix</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Transform(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a transform matrix from translation, scaling and rotation parameters
            Like the vvvv node Transform (3d)
            </summary>
            <param name="transX"></param>
            <param name="transY"></param>
            <param name="transZ"></param>
            <param name="scaleX"></param>
            <param name="scaleY"></param>
            <param name="scaleZ"></param>
            <param name="rotX"></param>
            <param name="rotY"></param>
            <param name="rotZ"></param>
            <returns>Transform matrix</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Transform(VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D,VVVV.Utils.VMath.Vector3D)">
            <summary>
            Creates a transform matrix from translation, scaling and rotation parameters given as 3d-vectors
            Like the vvvv node Transform (3d Vector)
            </summary>
            <param name="trans"></param>
            <param name="scale"></param>
            <param name="rot"></param>
            <returns>Transform matrix</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.PerspectiveLH(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Builds a left-handed perspective projection matrix based on a field of view.
            </summary>
            <param name="FOV">Camera angle in cycles, [0..0.5]</param>
            <param name="Near">Near Plane z</param>
            <param name="Far">Far Plane z</param>
            <param name="Aspect">Aspect Ratio</param>
            <returns>Projection matrix</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.PerspectiveRH(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Builds a right-handed perspective projection matrix based on a field of view.
            </summary>
            <param name="FOV">Camera angle in cycles, [0..0.5]</param>
            <param name="Near">Near Plane z</param>
            <param name="Far">Far Plane z</param>
            <param name="Aspect">Aspect Ratio</param>
            <returns>Projection matrix</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Transpose(VVVV.Utils.VMath.Matrix4x4)">
            <summary>
            Transpose a 4x4 matrix
            </summary>
            <param name="A"></param>
            <returns>Transpose of input matrix A</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Inverse(VVVV.Utils.VMath.Matrix4x4)">
            <summary>
            Optimized 4x4 matrix inversion using cramer's rule, found in the game engine http://www.ogre3d.org
            Note that the unary ! operator of Matrix4x4 does the same
            
            Code takes about 1,8ns to execute on intel core2 duo 2Ghz, the intel reference
            implementation (not assembly optimized) was about 2,2ns.
            http://www.intel.com/design/pentiumiii/sml/24504301.pdf
            </summary>
            <param name="A"></param>
            <returns>Inverse matrix of input matrix A</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.Det(VVVV.Utils.VMath.Matrix4x4)">
            <summary>
            Calculates the determinat of a 4x4 matrix
            Note that the unary ~ operator of Matrix4x4 does the same
            </summary>
            <param name="A"></param>
            <returns>Determinat of input matrix A</returns>
        </member>
        <member name="M:VVVV.Utils.VMath.VMath.BilerpMatrix(VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D,VVVV.Utils.VMath.Vector4D)">
            <summary>
            Builds a matrix that interpolates 4d-vectors like a 2d bilinear interpolation in x and y direction
            
            Should be used to transform 4d vectors with interpolation foacors in the 4d-form (x, y, x*y, 1) 
            </summary>
            <param name="P1">Upper left vector</param>
            <param name="P2">Upper right vector</param>
            <param name="P3">Lower right vector</param>
            <param name="P4">Lower left vector</param>
            <returns>Linear interpolation matrix, can be used to interpolate 4d vectors with interpolation factors in the 4d-form (x, y, x*y, 1)</returns>
        </member>
        <member name="T:VVVV.Utils.OSC.OSCBundle">
            <summary>
            OSCBundle
            </summary>
        </member>
        <member name="T:VVVV.Utils.OSC.OSCPacket">
            <summary>
            OSCPacket
            </summary>
        </member>
        <member name="T:VVVV.Utils.OSC.OSCMessage">
            <summary>
            OSCMessage
            </summary>
        </member>
        <member name="T:VVVV.Utils.OSC.OSCReceiver">
            <summary>
            OSCReceiver
            </summary>
        </member>
        <member name="T:VVVV.Utils.OSC.OSCTransmitter">
            <summary>
            OSCTransmitter
            </summary>
        </member>
        <member name="T:VVVV.Utils.PathUtils">
            <summary>
            Utility methods missing in the System.IO.Path class.
            </summary>
        </member>
        <member name="M:VVVV.Utils.PathUtils.MakeRelativePath(System.String,System.String)">
            <summary>
            Returns the relative path to reach toPath from fromPath.
            </summary>
        </member>
        <member name="M:VVVV.Utils.Reflection.TypeExtensions.GetCSharpName(System.Type)">
            <summary>
            Generates a CSharp like type name string.
            </summary>
            <param name="type">A .Net Type</param>
            <returns>Type name as one would write it in CSharp</returns>
        </member>
        <member name="M:VVVV.Utils.Reflection.TypeExtensions.GetCSharpName(System.Type,System.Boolean)">
            <summary>
            Generates a CSharp like type name string.
            </summary>
            <param name="type">A .Net Type</param>
            <param name="includeNamespace">If true, the return string comes with namespace prefix.</param>
            <returns>Type name as one would write it in CSharp</returns>
        </member>
        <member name="T:VVVV.Utils.SharedMemory.SharedMemoryCreationFlag">
            <summary>
            Enum for specifying whether a new shared memory 
            segment should be created or just attach to an existing one
            </summary>
        </member>
        <member name="T:VVVV.Utils.SharedMemory.Segment">
            <summary>
            This class wraps Win32 shared memory.
            </summary>
            
        </member>
        <member name="M:VVVV.Utils.SharedMemory.Segment.Lock">
            <summary>
            Provides a cross processs lock on the named mutex
            </summary>
        </member>
        <member name="M:VVVV.Utils.SharedMemory.Segment.Unlock">
            <summary>
            Releases to cross process lock on the named mutex
            </summary>
        </member>
        <member name="M:VVVV.Utils.SharedMemory.Segment.GetData">
            <summary>
            Returns the object graph stored in the shared memory segment
            </summary>
            <returns>System.Object - root of object graph</returns>
        </member>
        <member name="M:VVVV.Utils.SharedMemory.Segment.SetData(System.Object)">
            <summary>
            Stores serializable object graph in shared memory
            </summary>
            <param name="obj">System.Object root of object graph to be stored in shared memory</param>
        </member>
        <member name="M:VVVV.Utils.SharedMemory.Segment.Finalize">
            <summary>
            Finalizer to free up shared memory segment native handle
            </summary>
        </member>
        <member name="M:VVVV.Utils.SharedMemory.Segment.Dispose">
            <summary>
            IDisposable.Dispose allow timely clean up and removed the need for finalization
            </summary>
        </member>
        <member name="M:VVVV.Utils.SharedMemory.Segment.Dispose(System.Boolean)">
            <summary>
            Common clean up method
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:VVVV.Utils.SharedMemory.Segment.CopyStreamToSharedMemory(System.IO.Stream)">
            <summary>
            Copies stream to shared memory segment using unsafe pointers
            </summary>
            <param name="stream"> System.IO.Stream - data to be copied to shared memory</param>
        </member>
        <member name="M:VVVV.Utils.SharedMemory.Segment.CopySharedMemoryToStream(System.IO.Stream)">
            <summary>
            Copies shared memory data to passed stream using unsafe pointers
            </summary>
            <param name="stream">System.IO.Stream - stream to receive data</param>
        </member>
        <member name="P:VVVV.Utils.SharedMemory.Segment.WaitHandle">
            <summary>
            Provides access to the cross process waithandle
            </summary>
        </member>
        <member name="T:VVVV.Utils.SharedMemory.Win32Native">
            <summary>
            Summary description for Win32Native.
            </summary>
            
        </member>
    </members>
</doc>
